#!/usr/bin/env node

/**
 * Slack Notification Utility
 * 
 * This utility provides comprehensive Slack notifications for all automation scripts,
 * deployments, and page builds. It includes success/failure notifications with detailed
 * error logging and summary information.
 * 
 * @author 180DC ESCP Development Team
 * @version 1.0.0
 * @since 2024-01-01
 */

import { WebClient } from '@slack/web-api';
import dotenv from 'dotenv';

dotenv.config();

/**
 * SlackNotificationManager class handles all Slack notifications
 * for automations, deployments, and page builds
 */
class SlackNotificationManager {
  constructor() {
    this.client = new WebClient(process.env.SLACK_BOT_TOKEN);
    this.channel = process.env.SLACK_CHANNEL || '#automation-updates';
    this.isEnabled = !!(process.env.SLACK_BOT_TOKEN && process.env.SLACK_CHANNEL);
    
    if (!this.isEnabled) {
      console.warn('‚ö†Ô∏è Slack notifications disabled - missing SLACK_BOT_TOKEN or SLACK_CHANNEL');
    }
  }

  /**
   * Send a notification for automation success
   * @param {Object} options - Notification options
   * @param {string} options.script - Script name
   * @param {string} options.summary - Summary of what was accomplished
   * @param {Object} options.results - Results object with counts
   * @param {number} options.duration - Duration in milliseconds
   */
  async notifyAutomationSuccess({ script, summary, results, duration }) {
    if (!this.isEnabled) return;

    const durationText = duration ? ` (${Math.round(duration / 1000)}s)` : '';
    let message = `‚úÖ *${script} Completed Successfully*${durationText}\n\n`;
    message += `üìä *Summary:* ${summary}\n\n`;
    
    if (results) {
      message += `üìà *Results:*\n`;
      if (results.created) message += `‚Ä¢ ‚úÖ Created: ${results.created}\n`;
      if (results.updated) message += `‚Ä¢ üîÑ Updated: ${results.updated}\n`;
      if (results.deleted) message += `‚Ä¢ üóëÔ∏è Deleted: ${results.deleted}\n`;
      if (results.processed) message += `‚Ä¢ üìä Processed: ${results.processed}\n`;
      if (results.skipped) message += `‚Ä¢ ‚è≠Ô∏è Skipped: ${results.skipped}\n`;
    }

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for automation failure
   * @param {Object} options - Notification options
   * @param {string} options.script - Script name
   * @param {Error} options.error - Error object
   * @param {string} options.context - Additional context
   * @param {Object} options.partialResults - Any partial results before failure
   */
  async notifyAutomationFailure({ script, error, context, partialResults }) {
    if (!this.isEnabled) return;

    let message = `‚ùå *${script} Failed*\n\n`;
    message += `üö® *Error:* ${error.message}\n`;
    
    if (context) {
      message += `üìù *Context:* ${context}\n`;
    }

    if (partialResults) {
      message += `\nüìä *Partial Results:*\n`;
      if (partialResults.created) message += `‚Ä¢ ‚úÖ Created: ${partialResults.created}\n`;
      if (partialResults.updated) message += `‚Ä¢ üîÑ Updated: ${partialResults.updated}\n`;
      if (partialResults.processed) message += `‚Ä¢ üìä Processed: ${partialResults.processed}\n`;
    }

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    // Add error details in a code block
    if (error.stack) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `\`\`\`\n${error.stack}\n\`\`\``
        }
      });
    }

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for deployment success
   * @param {Object} options - Notification options
   * @param {string} options.service - Service name (e.g., "Website", "Webhook")
   * @param {string} options.platform - Deployment platform
   * @param {string} options.url - Deployment URL
   * @param {number} options.duration - Duration in milliseconds
   */
  async notifyDeploymentSuccess({ service, platform, url, duration }) {
    if (!this.isEnabled) return;

    const durationText = duration ? ` (${Math.round(duration / 1000)}s)` : '';
    let message = `üöÄ *${service} Deployment Successful*${durationText}\n\n`;
    message += `üåê *Platform:* ${platform}\n`;
    
    if (url) {
      message += `üîó *URL:* ${url}\n`;
    }

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for deployment failure
   * @param {Object} options - Notification options
   * @param {string} options.service - Service name
   * @param {string} options.platform - Deployment platform
   * @param {Error} options.error - Error object
   * @param {string} options.logs - Deployment logs
   */
  async notifyDeploymentFailure({ service, platform, error, logs }) {
    if (!this.isEnabled) return;

    let message = `‚ùå *${service} Deployment Failed*\n\n`;
    message += `üåê *Platform:* ${platform}\n`;
    message += `üö® *Error:* ${error.message}\n`;

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    // Add error details and logs
    if (error.stack) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Error Details:*\n\`\`\`\n${error.stack}\n\`\`\``
        }
      });
    }

    if (logs) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Deployment Logs:*\n\`\`\`\n${logs}\n\`\`\``
        }
      });
    }

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for page build success
   * @param {Object} options - Notification options
   * @param {string} options.page - Page name
   * @param {string} options.url - Page URL
   * @param {number} options.duration - Duration in milliseconds
   */
  async notifyPageBuildSuccess({ page, url, duration }) {
    if (!this.isEnabled) return;

    const durationText = duration ? ` (${Math.round(duration / 1000)}s)` : '';
    let message = `üìÑ *${page} Build Successful*${durationText}\n\n`;
    
    if (url) {
      message += `üîó *URL:* ${url}\n`;
    }

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for page build failure
   * @param {Object} options - Notification options
   * @param {string} options.page - Page name
   * @param {Error} options.error - Error object
   * @param {string} options.logs - Build logs
   */
  async notifyPageBuildFailure({ page, error, logs }) {
    if (!this.isEnabled) return;

    let message = `‚ùå *${page} Build Failed*\n\n`;
    message += `üö® *Error:* ${error.message}\n`;

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    // Add error details and logs
    if (error.stack) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Error Details:*\n\`\`\`\n${error.stack}\n\`\`\``
        }
      });
    }

    if (logs) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Build Logs:*\n\`\`\`\n${logs}\n\`\`\``
        }
      });
    }

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a notification for webhook processing
   * @param {Object} options - Notification options
   * @param {string} options.status - Success or failure
   * @param {string} options.webhookType - Type of webhook
   * @param {Object} options.data - Webhook data
   * @param {Error} options.error - Error if failed
   */
  async notifyWebhookProcessing({ status, webhookType, data, error }) {
    if (!this.isEnabled) return;

    const isSuccess = status === 'success';
    const emoji = isSuccess ? '‚úÖ' : '‚ùå';
    const statusText = isSuccess ? 'Processed Successfully' : 'Failed';

    let message = `${emoji} *${webhookType} Webhook ${statusText}*\n\n`;
    
    if (data) {
      message += `üìä *Data:*\n`;
      if (data.session_id) message += `‚Ä¢ Session ID: ${data.session_id}\n`;
      if (data.title) message += `‚Ä¢ Title: ${data.title}\n`;
      if (data.participants) message += `‚Ä¢ Participants: ${Array.isArray(data.participants) ? data.participants.join(', ') : data.participants}\n`;
    }

    if (error) {
      message += `\nüö® *Error:* ${error.message}\n`;
    }

    message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: message
        }
      }
    ];

    // Add error details if failed
    if (error && error.stack) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Error Details:*\n\`\`\`\n${error.stack}\n\`\`\``
        }
      });
    }

    await this.sendMessage(message, blocks);
  }

  /**
   * Send a generic notification
   * @param {string} title - Notification title
   * @param {string} message - Notification message
   * @param {string} level - Notification level (info, success, warning, error)
   */
  async notifyGeneric({ title, message, level = 'info' }) {
    if (!this.isEnabled) return;

    const emojis = {
      info: '‚ÑπÔ∏è',
      success: '‚úÖ',
      warning: '‚ö†Ô∏è',
      error: '‚ùå'
    };

    const emoji = emojis[level] || '‚ÑπÔ∏è';
    const fullMessage = `${emoji} *${title}*\n\n${message}\n\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: fullMessage
        }
      }
    ];

    await this.sendMessage(fullMessage, blocks);
  }

  /**
   * Send a message to Slack
   * @param {string} text - Message text
   * @param {Array} blocks - Slack blocks (optional)
   */
  async sendMessage(text, blocks = null) {
    if (!this.isEnabled) {
      console.log('üì± Slack notification (disabled):', text);
      return;
    }

    try {
      const payload = {
        channel: this.channel,
        text: text,
        blocks: blocks,
        unfurl_links: false,
        unfurl_media: false
      };

      const response = await fetch('https://slack.com/api/chat.postMessage', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`‚úÖ Slack notification sent: ${result.ts}`);
        return result;
      } else {
        const errorText = await response.text();
        console.error('‚ùå Failed to send Slack notification:', errorText);
        throw new Error(`Slack API error: ${errorText}`);
      }
    } catch (error) {
      console.error('‚ùå Error sending Slack notification:', error);
      throw error;
    }
  }

  /**
   * Test the Slack connection
   */
  async testConnection() {
    if (!this.isEnabled) {
      console.log('‚ö†Ô∏è Slack notifications are disabled');
      return false;
    }

    try {
      const result = await this.client.auth.test();
      console.log('‚úÖ Slack connection successful');
      console.log(`Bot: ${result.user}`);
      console.log(`Team: ${result.team}`);
      return true;
    } catch (error) {
      console.error('‚ùå Slack connection failed:', error.message);
      return false;
    }
  }

  /**
   * Get channel information
   */
  async getChannelInfo() {
    if (!this.isEnabled) return null;

    try {
      const result = await this.client.conversations.info({
        channel: this.channel
      });
      return result.channel;
    } catch (error) {
      console.error('Error getting channel info:', error);
      return null;
    }
  }

  /**
   * Send notification for clients with failed logo conversions
   * @param {Array} failedLogos - Array of failed logo objects
   */
  async notifyFailedLogos(failedLogos) {
    if (!this.isEnabled || !failedLogos || failedLogos.length === 0) return;

    try {
      let message = `‚ö†Ô∏è *Client Logo Conversion Failures*\n\n`;
      message += `The following clients were excluded from sync due to logo conversion failures:\n\n`;

      failedLogos.forEach((failedLogo, index) => {
        message += `${index + 1}. *${failedLogo.name}*\n`;
        message += `   ‚Ä¢ Logo URL: ${failedLogo.logoUrl}\n`;
        message += `   ‚Ä¢ Error: ${failedLogo.error}\n\n`;
      });

      message += `üîß *Action Required:*\n`;
      message += `Please update the logo URLs for these clients in Google Sheets with valid image formats (JPEG, PNG, WebP, GIF, BMP, TIFF).\n\n`;
      message += `üí° *Tip:* Ensure the logo URLs are publicly accessible and point to actual image files.`;

      const result = await this.client.chat.postMessage({
        channel: this.channel,
        text: 'Client Logo Conversion Failures',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: message
            }
          }
        ]
      });

      console.log('‚úÖ Failed logos notification sent to Slack');
      return result;
    } catch (error) {
      console.error('‚ùå Error sending failed logos notification:', error);
      return null;
    }
  }

  /**
   * Send notification for team members with failed avatar conversions
   * @param {Array} failedAvatars - Array of failed avatar objects
   */
  async notifyFailedAvatars(failedAvatars) {
    if (!this.isEnabled || !failedAvatars || failedAvatars.length === 0) return;

    try {
      let message = `‚ö†Ô∏è *Team Member Avatar Conversion Failures*\n\n`;
      message += `The following team members were excluded from sync due to avatar conversion failures:\n\n`;

      failedAvatars.forEach((failedAvatar, index) => {
        message += `${index + 1}. *${failedAvatar.name}*\n`;
        message += `   ‚Ä¢ Avatar URL: ${failedAvatar.avatarUrl}\n`;
        message += `   ‚Ä¢ Error: ${failedAvatar.error}\n\n`;
      });

      message += `üîß *Action Required:*\n`;
      message += `Please ask these team members to update their Slack profile pictures with valid image formats (JPEG, PNG, WebP, GIF, BMP, TIFF).\n\n`;
      message += `üí° *Tip:* Ensure the profile pictures are publicly accessible and point to actual image files.`;

      const result = await this.client.chat.postMessage({
        channel: this.channel,
        text: 'Team Member Avatar Conversion Failures',
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: message
            }
          }
        ]
      });

      console.log('‚úÖ Failed avatars notification sent to Slack');
      return result;
    } catch (error) {
      console.error('‚ùå Error sending failed avatars notification:', error);
      return null;
    }
  }

  /**
   * Send debugging notification for webhook reception
   * @param {Object} options - Debug options
   * @param {Object} options.webhookData - Raw webhook data
   * @param {Object} options.headers - Request headers
   * @param {string} options.source - Source of webhook (e.g., "Cloudflare Worker", "Express Server")
   */
  async notifyWebhookReceived({ webhookData, headers, source = "Unknown" }) {
    if (!this.isEnabled) return;

    try {
      let message = `üîî *Read.ai Webhook Received*\n\n`;
      message += `üì° *Source:* ${source}\n`;
      message += `‚è∞ *Time:* ${new Date().toLocaleString()}\n\n`;
      
      message += `üìä *Webhook Data:*\n`;
      if (webhookData.session_id) message += `‚Ä¢ Session ID: \`${webhookData.session_id}\`\n`;
      if (webhookData.trigger) message += `‚Ä¢ Trigger: \`${webhookData.trigger}\`\n`;
      if (webhookData.title) message += `‚Ä¢ Title: ${webhookData.title}\n`;
      if (webhookData.start_time) message += `‚Ä¢ Start Time: ${webhookData.start_time}\n`;
      if (webhookData.end_time) message += `‚Ä¢ End Time: ${webhookData.end_time}\n`;
      if (webhookData.participants) {
        const participants = Array.isArray(webhookData.participants) ? webhookData.participants : [webhookData.participants];
        message += `‚Ä¢ Participants: ${participants.join(', ')}\n`;
      }
      if (webhookData.owner) message += `‚Ä¢ Owner: ${webhookData.owner}\n`;

      // Check for meeting data presence
      const hasMeetingData = webhookData.session_id && webhookData.trigger && webhookData.title;
      message += `\nüîç *Meeting Detection:* ${hasMeetingData ? '‚úÖ Meeting data present' : '‚ùå Missing meeting data'}\n`;

      if (headers) {
        message += `\nüìã *Headers:*\n`;
        if (headers['user-agent']) message += `‚Ä¢ User-Agent: ${headers['user-agent']}\n`;
        if (headers['content-type']) message += `‚Ä¢ Content-Type: ${headers['content-type']}\n`;
        if (headers['x-forwarded-for']) message += `‚Ä¢ X-Forwarded-For: ${headers['x-forwarded-for']}\n`;
      }

      const blocks = [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: message
          }
        }
      ];

      await this.sendMessage(message, blocks);
    } catch (error) {
      console.error('‚ùå Error sending webhook received notification:', error);
    }
  }

  /**
   * Send debugging notification for meeting data validation
   * @param {Object} options - Validation options
   * @param {Object} options.webhookData - Webhook data being validated
   * @param {boolean} options.isValid - Whether validation passed
   * @param {Array} options.missingFields - Array of missing required fields
   * @param {string} options.trigger - Webhook trigger type
   */
  async notifyMeetingValidation({ webhookData, isValid, missingFields = [], trigger }) {
    if (!this.isEnabled) return;

    try {
      const emoji = isValid ? '‚úÖ' : '‚ùå';
      const statusText = isValid ? 'Meeting Data Valid' : 'Meeting Data Invalid';
      
      let message = `${emoji} *${statusText}*\n\n`;
      message += `üìä *Session ID:* \`${webhookData.session_id || 'Missing'}\`\n`;
      message += `üéØ *Trigger:* \`${trigger || 'Missing'}\`\n`;
      message += `üìù *Title:* ${webhookData.title || 'Missing'}\n`;

      if (!isValid && missingFields.length > 0) {
        message += `\n‚ùå *Missing Required Fields:*\n`;
        missingFields.forEach(field => {
          message += `‚Ä¢ ${field}\n`;
        });
      }

      // Check if trigger is correct for meeting processing
      const isCorrectTrigger = trigger === 'meeting_end';
      message += `\nüîç *Trigger Validation:* ${isCorrectTrigger ? '‚úÖ Correct trigger (meeting_end)' : '‚ùå Wrong trigger (expected: meeting_end)'}\n`;

      // Check for additional meeting data
      const hasParticipants = webhookData.participants && (Array.isArray(webhookData.participants) ? webhookData.participants.length > 0 : webhookData.participants);
      const hasSummary = webhookData.summary && webhookData.summary.trim().length > 0;
      const hasTranscript = webhookData.transcript && webhookData.transcript.trim().length > 0;
      
      message += `\nüìã *Additional Data:*\n`;
      message += `‚Ä¢ Participants: ${hasParticipants ? '‚úÖ Present' : '‚ùå Missing'}\n`;
      message += `‚Ä¢ Summary: ${hasSummary ? '‚úÖ Present' : '‚ùå Missing'}\n`;
      message += `‚Ä¢ Transcript: ${hasTranscript ? '‚úÖ Present' : '‚ùå Missing'}\n`;

      message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

      const blocks = [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: message
          }
        }
      ];

      await this.sendMessage(message, blocks);
    } catch (error) {
      console.error('‚ùå Error sending meeting validation notification:', error);
    }
  }

  /**
   * Send debugging notification for Notion database creation
   * @param {Object} options - Creation options
   * @param {boolean} options.success - Whether creation was successful
   * @param {string} options.notionPageId - Notion page ID if successful
   * @param {Object} options.webhookData - Original webhook data
   * @param {Error} options.error - Error if failed
   * @param {number} options.duration - Processing duration in milliseconds
   */
  async notifyNotionCreation({ success, notionPageId, webhookData, error, duration }) {
    if (!this.isEnabled) return;

    try {
      const emoji = success ? '‚úÖ' : '‚ùå';
      const statusText = success ? 'Notion Page Created Successfully' : 'Notion Page Creation Failed';
      const durationText = duration ? ` (${Math.round(duration)}ms)` : '';
      
      let message = `${emoji} *${statusText}*${durationText}\n\n`;
      
      if (success) {
        message += `üÜî *Notion Page ID:* \`${notionPageId}\`\n`;
        message += `üìù *Meeting Title:* ${webhookData.title || 'Unknown'}\n`;
        message += `üìä *Session ID:* \`${webhookData.session_id || 'Unknown'}\`\n`;
        
        if (webhookData.participants) {
          const participants = Array.isArray(webhookData.participants) ? webhookData.participants : [webhookData.participants];
          message += `üë• *Participants:* ${participants.join(', ')}\n`;
        }
        
        if (webhookData.start_time && webhookData.end_time) {
          message += `‚è∞ *Duration:* ${webhookData.start_time} ‚Üí ${webhookData.end_time}\n`;
        }
        
        message += `\nüîó *Notion Link:* https://notion.so/${notionPageId.replace(/-/g, '')}\n`;
      } else {
        message += `üö® *Error:* ${error.message}\n`;
        message += `üìù *Meeting Title:* ${webhookData.title || 'Unknown'}\n`;
        message += `üìä *Session ID:* \`${webhookData.session_id || 'Unknown'}\`\n`;
        
        if (error.stack) {
          message += `\nüîç *Error Details:*\n\`\`\`\n${error.stack.substring(0, 500)}...\n\`\`\``;
        }
      }

      message += `\n‚è∞ *Time:* ${new Date().toLocaleString()}`;

      const blocks = [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: message
          }
        }
      ];

      await this.sendMessage(message, blocks);
    } catch (error) {
      console.error('‚ùå Error sending Notion creation notification:', error);
    }
  }
}

export default SlackNotificationManager;
